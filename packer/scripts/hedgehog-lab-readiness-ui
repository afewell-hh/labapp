#!/bin/bash
# hedgehog-lab-readiness-ui
# Terminal UI for displaying Hedgehog Lab initialization progress
# Shows progress bar, current step, log activity, and time estimates

set -euo pipefail

# Configuration paths (can be overridden via environment variables)
STATE_FILE="${STATE_FILE:-/var/lib/hedgehog-lab/state.json}"
LOG_FILE="${LOG_FILE:-/var/log/hedgehog-lab-init.log}"
STAMP_FILE="${STAMP_FILE:-/var/lib/hedgehog-lab/initialized}"

# UI refresh rate (seconds)
REFRESH_INTERVAL=2

# ANSI color codes and control sequences
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Terminal control sequences
CLEAR_SCREEN='\033[2J'
CURSOR_HOME='\033[H'
CURSOR_HIDE='\033[?25l'
CURSOR_SHOW='\033[?25h'
CLEAR_LINE='\033[2K'

# Trap to ensure cursor is shown on exit
trap 'echo -e "${CURSOR_SHOW}"; exit' EXIT INT TERM

# Helper function to get terminal dimensions
get_terminal_size() {
    if command -v tput &>/dev/null; then
        TERM_COLS=$(tput cols 2>/dev/null || echo 80)
        TERM_LINES=$(tput lines 2>/dev/null || echo 24)
    else
        TERM_COLS=80
        TERM_LINES=24
    fi
}

# Parse JSON field from state file (simple parsing without jq)
get_state_field() {
    local field="$1"
    local default="${2:-unknown}"

    if [ ! -f "$STATE_FILE" ]; then
        echo "$default"
        return
    fi

    # Extract field value from JSON (handles both compact and pretty-printed JSON)
    # Pattern matches: "field": "value" or "field":"value" (with or without spaces)
    # Uses || true to prevent pipefail from exiting when key is missing
    local value=$(grep "\"$field\"" "$STATE_FILE" 2>/dev/null | head -1 | sed 's/.*"'"$field"'"[[:space:]]*:[[:space:]]*"\?\([^",}]*\)"\?.*/\1/' || true)

    if [ -z "$value" ] || [ "$value" = "$(grep "\"$field\"" "$STATE_FILE" 2>/dev/null | head -1 || true)" ]; then
        # If value is empty or unchanged (sed substitution failed), return default
        echo "$default"
    else
        echo "$value"
    fi
}

# Get array from JSON (returns count)
get_array_count() {
    local field="$1"

    if [ ! -f "$STATE_FILE" ]; then
        echo "0"
        return
    fi

    # Extract the array and count items between [ and ]
    # Look for the field, extract content between [ and ], count quoted strings
    # Uses || true to prevent pipefail from exiting when key is missing
    local array_content=$(grep "\"$field\"" "$STATE_FILE" 2>/dev/null | sed 's/.*\[\(.*\)\].*/\1/' || true)

    if [ -z "$array_content" ] || [ "$array_content" = "[]" ]; then
        echo "0"
        return
    fi

    # Count comma-separated items (add 1 since n items have n-1 commas)
    # Uses || true to handle case where no commas exist (single item)
    local comma_count=$(echo "$array_content" | grep -o "," 2>/dev/null | wc -l || echo "0")
    echo $((comma_count + 1))
}

# Calculate progress percentage
calculate_progress() {
    local completed="$1"
    local total="$2"

    if [ "$total" -eq 0 ]; then
        echo "0"
        return
    fi

    echo $(( (completed * 100) / total ))
}

# Calculate estimated time remaining
calculate_eta() {
    local started_at="$1"
    local progress="$2"

    if [ "$progress" -eq 0 ]; then
        echo "calculating..."
        return
    fi

    # Parse ISO 8601 timestamp to epoch
    local start_epoch=$(date -d "$started_at" +%s 2>/dev/null || echo "0")
    if [ "$start_epoch" -eq 0 ]; then
        echo "unknown"
        return
    fi

    local now_epoch=$(date +%s)
    local elapsed=$((now_epoch - start_epoch))

    # Calculate estimated total time based on current progress
    local estimated_total=$((elapsed * 100 / progress))
    local remaining=$((estimated_total - elapsed))

    if [ "$remaining" -lt 60 ]; then
        echo "${remaining}s"
    elif [ "$remaining" -lt 3600 ]; then
        echo "$((remaining / 60))m $((remaining % 60))s"
    else
        echo "$((remaining / 3600))h $((remaining % 3600 / 60))m"
    fi
}

# Format elapsed time
format_elapsed() {
    local started_at="$1"

    local start_epoch=$(date -d "$started_at" +%s 2>/dev/null || echo "0")
    if [ "$start_epoch" -eq 0 ]; then
        echo "unknown"
        return
    fi

    local now_epoch=$(date +%s)
    local elapsed=$((now_epoch - start_epoch))

    if [ "$elapsed" -lt 60 ]; then
        echo "${elapsed}s"
    elif [ "$elapsed" -lt 3600 ]; then
        echo "$((elapsed / 60))m $((elapsed % 60))s"
    else
        echo "$((elapsed / 3600))h $((elapsed % 3600 / 60))m"
    fi
}

# Draw progress bar
draw_progress_bar() {
    local percentage="$1"
    local width="${2:-50}"

    # Calculate filled portion
    local filled=$((percentage * width / 100))
    local empty=$((width - filled))

    # Build progress bar
    local bar="["

    # Filled portion
    for ((i=0; i<filled; i++)); do
        bar+="="
    done

    # Current position indicator
    if [ "$percentage" -lt 100 ] && [ "$filled" -lt "$width" ]; then
        bar+=">"
        empty=$((empty - 1))
    fi

    # Empty portion
    for ((i=0; i<empty; i++)); do
        bar+=" "
    done

    bar+="]"

    # Color based on progress
    if [ "$percentage" -eq 100 ]; then
        echo -e "${GREEN}${bar}${NC}"
    elif [ "$percentage" -gt 50 ]; then
        echo -e "${CYAN}${bar}${NC}"
    else
        echo -e "${YELLOW}${bar}${NC}"
    fi
}

# Get recent log lines
get_recent_logs() {
    local count="${1:-5}"

    if [ ! -f "$LOG_FILE" ]; then
        echo "  ${DIM}No logs available yet...${NC}"
        return
    fi

    # Get last N lines, format them nicely
    tail -n "$count" "$LOG_FILE" 2>/dev/null | while IFS= read -r line; do
        # Truncate long lines to terminal width
        local max_width=$((TERM_COLS - 2))
        if [ ${#line} -gt "$max_width" ]; then
            line="${line:0:$max_width}..."
        fi
        echo "  ${DIM}${line}${NC}"
    done
}

# Draw the header banner
draw_header() {
    echo -e "${BOLD}${BLUE}"
    echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "â”‚         Hedgehog Lab Appliance Initialization                  â”‚"
    echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo -e "${NC}"
}

# Draw completion banner
draw_ready_banner() {
    echo ""
    echo -e "${BOLD}${GREEN}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                                                                  â•‘"
    echo "â•‘                  ðŸŽ‰  LAB IS READY!  ðŸŽ‰                           â•‘"
    echo "â•‘                                                                  â•‘"
    echo "â•‘          Hedgehog Lab Appliance Initialized Successfully        â•‘"
    echo "â•‘                                                                  â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

# Display current status (single snapshot)
show_status() {
    get_terminal_size

    # Clear screen and position cursor
    echo -e "${CLEAR_SCREEN}${CURSOR_HOME}"

    # Check if already initialized
    if [ -f "$STAMP_FILE" ]; then
        draw_ready_banner
        echo ""
        echo -e "${BOLD}Status:${NC} Initialization complete"

        if [ -f "$STAMP_FILE" ]; then
            local init_time=$(grep "initialized_at" "$STAMP_FILE" 2>/dev/null | sed 's/.*: "\([^"]*\)".*/\1/')
            if [ -n "$init_time" ]; then
                echo -e "${BOLD}Completed:${NC} $init_time"
            fi
        fi

        echo ""
        echo -e "${CYAN}â„¹${NC} Run ${BOLD}hh-lab status${NC} for detailed service information"
        echo ""
        return
    fi

    # Get current state
    local status=$(get_state_field "status" "unknown")
    local current_module=$(get_state_field "current_module" "none")
    local build_type=$(get_state_field "build_type" "unknown")
    local started_at=$(get_state_field "started_at" "unknown")
    local steps_completed=$(get_array_count "steps_completed")

    # Determine total steps based on build type
    local total_steps=5
    if [ "$build_type" = "prewarmed" ]; then
        total_steps=2
    fi

    # Calculate progress
    local progress=$(calculate_progress "$steps_completed" "$total_steps")

    # Draw UI
    draw_header

    echo -e "${BOLD}Status:${NC} ${CYAN}${status}${NC}"
    echo -e "${BOLD}Build Type:${NC} ${build_type}"
    echo -e "${BOLD}Current Step:${NC} ${MAGENTA}${current_module}${NC}"
    echo -e "${BOLD}Progress:${NC} ${steps_completed}/${total_steps} steps completed"
    echo ""

    # Progress bar
    local bar_width=$((TERM_COLS - 20))
    if [ "$bar_width" -gt 50 ]; then
        bar_width=50
    fi
    echo -e "${BOLD}Progress:${NC} $(draw_progress_bar "$progress" "$bar_width") ${BOLD}${progress}%${NC}"
    echo ""

    # Time information
    if [ "$started_at" != "unknown" ]; then
        local elapsed=$(format_elapsed "$started_at")
        local eta=$(calculate_eta "$started_at" "$progress")
        echo -e "${BOLD}Elapsed:${NC} $elapsed"
        echo -e "${BOLD}Estimated Remaining:${NC} $eta"
        echo ""
    fi

    # Recent log activity
    echo -e "${BOLD}Recent Activity:${NC}"
    echo ""
    get_recent_logs 5
    echo ""

    # Status message
    if [ "$status" = "failed" ]; then
        echo -e "${RED}âœ—${NC} ${BOLD}Initialization failed.${NC} Check logs at: ${LOG_FILE}"
    elif [ "$status" = "completed" ]; then
        echo -e "${GREEN}âœ“${NC} ${BOLD}Initialization completed successfully!${NC}"
    else
        echo -e "${YELLOW}âš™${NC}  ${DIM}Initialization in progress... (press Ctrl+C to exit monitor)${NC}"
    fi

    echo ""
}

# Monitor mode - continuously update display
monitor_mode() {
    # Hide cursor for cleaner display
    echo -e "${CURSOR_HIDE}"

    local last_status=""

    while true; do
        # Show current status
        show_status

        # Check if initialization is complete
        if [ -f "$STAMP_FILE" ]; then
            echo -e "${CURSOR_SHOW}"
            break
        fi

        # Check if initialization failed
        local current_status=$(get_state_field "status" "unknown")
        if [ "$current_status" = "failed" ]; then
            echo -e "${CURSOR_SHOW}"
            exit 1
        fi

        # Wait before next update
        sleep "$REFRESH_INTERVAL"
    done
}

# Display help message
show_help() {
    cat <<EOF
Hedgehog Lab Readiness UI

Usage:
    hedgehog-lab-readiness-ui [COMMAND]

Commands:
    monitor     Continuously monitor initialization progress (default)
    status      Show current status snapshot and exit
    help        Show this help message

Examples:
    # Monitor initialization in real-time
    hedgehog-lab-readiness-ui
    hedgehog-lab-readiness-ui monitor

    # Get current status once
    hedgehog-lab-readiness-ui status

Description:
    This tool provides a terminal-based UI for monitoring the Hedgehog Lab
    appliance initialization process. It displays:

    - Progress bar with completion percentage
    - Current initialization step
    - Recent log activity
    - Elapsed time and estimated time remaining
    - Success/failure status

    The tool reads state from $STATE_FILE
    and logs from $LOG_FILE

EOF
}

# Main function
main() {
    local command="${1:-monitor}"

    case "$command" in
        monitor)
            monitor_mode
            ;;
        status)
            show_status
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo "Unknown command: $command"
            echo "Run 'hedgehog-lab-readiness-ui help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
