#!/bin/bash
# hhfab-vlab-runner
# Wrapper script for launching hhfab VLAB in a detached tmux session
# This script is called by the hhfab-vlab.service systemd unit
#
# Features:
# - Runs hhfab vlab up in a persistent, detachable tmux session
# - Handles retries and logging
# - Creates state marker on successful completion
# - Allows students to inspect via `tmux attach -t hhfab-vlab`

set -euo pipefail

# Configuration
TMUX_SESSION_NAME="${TMUX_SESSION_NAME:-hhfab-vlab}"
VLAB_WORK_DIR="${VLAB_WORK_DIR:-/opt/hedgehog/vlab}"
VLAB_TIMEOUT="${VLAB_TIMEOUT:-7200}"
LOG_FILE="${LOG_FILE:-/var/log/hedgehog-lab/modules/vlab.log}"
STATE_FILE="/var/lib/hedgehog-lab/vlab-initialized"
HHFAB_CMD="hhfab vlab up --controls-restricted=false --ready wait"

# Telemetry + TLS configuration
PROM_REMOTE_WRITE_PORT="${PROM_REMOTE_WRITE_PORT:-9090}"
ALLOY_PROM_REMOTE_WRITE_URL="${ALLOY_PROM_REMOTE_WRITE_URL:-}"
ALLOY_PROM_SEND_INTERVAL="${ALLOY_PROM_SEND_INTERVAL:-120}"
ALLOY_PROM_LABEL_ENV="${ALLOY_PROM_LABEL_ENV:-vlab}"
ALLOY_PROM_LABEL_CLUSTER="${ALLOY_PROM_LABEL_CLUSTER:-emc}"
# Optional extra SAN entries (space or comma separated)
EXTRA_TLS_SANS="${EXTRA_TLS_SANS:-}"

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

# Logging functions
log() {
    local level="${1:-INFO}"
    shift
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*" | tee -a "$LOG_FILE"
}

log_info() {
    log "INFO" "$@"
}

log_warn() {
    log "WARN" "$@"
}

log_error() {
    log "ERROR" "$@"
}

# Build a host-reachable Prometheus remote_write URL for Alloy.
default_prom_remote_write_url() {
    # Prefer host-local bridges (libvirt/k3d/docker) so telemetry stays inside the VM.
    local candidates=("192.168.122.1" "172.18.0.1" "172.19.0.1" "172.17.0.1")

    # Fall back to first non-loopback host IP, then loopback.
    local primary_ip
    primary_ip=$(hostname -I 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i !~ /^127\./) {print $i; exit}}')
    candidates+=("$primary_ip" "127.0.0.1")

    for ip in "${candidates[@]}"; do
        if [ -n "$ip" ]; then
            echo "http://${ip}:${PROM_REMOTE_WRITE_PORT}/api/v1/write"
            return
        fi
    done
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites for hhfab VLAB..."

    # Check for tmux
    if ! command -v tmux &> /dev/null; then
        log_error "tmux command not found. Cannot create detached session."
        return 1
    fi

    # Check for hhfab
    if ! command -v hhfab &> /dev/null; then
        log_error "hhfab command not found. Cannot start VLAB."
        return 1
    fi

    # Check working directory
    if [ ! -d "$VLAB_WORK_DIR" ]; then
        log_error "VLAB working directory does not exist: $VLAB_WORK_DIR"
        return 1
    fi

    # Check if already initialized
    if [ -f "$VLAB_WORK_DIR/fab.yaml" ]; then
        log_info "VLAB working directory already initialized"
    else
        log_info "VLAB working directory needs initialization"
    fi

    return 0
}

# Initialize VLAB working directory if needed
init_vlab_workdir() {
    log_info "Initializing VLAB working directory at $VLAB_WORK_DIR..."

    cd "$VLAB_WORK_DIR" || {
        log_error "Failed to change to VLAB working directory"
        return 1
    }

    # Initialize hhfab if not already initialized
    if [ ! -f "$VLAB_WORK_DIR/fab.yaml" ]; then
        log_info "Initializing hhfab with development credentials..."
        if ! hhfab init --dev >> "$LOG_FILE" 2>&1; then
            log_error "Failed to initialize hhfab"
            return 1
        fi
        log_info "hhfab initialized successfully"
    fi

    # Generate wiring diagram if not present
    if [ ! -f "$VLAB_WORK_DIR/wiring.yaml" ]; then
        log_info "Generating VLAB wiring diagram..."
        if ! hhfab vlab gen >> "$LOG_FILE" 2>&1; then
            log_error "Failed to generate wiring diagram"
            return 1
        fi
        log_info "Wiring diagram generated successfully"
    fi

    return 0
}

# Build TLS SAN list for controller certificate and inject Alloy telemetry
# configuration into fab.yaml before launching the lab. Idempotent: re-runs
# will merge new SANs and only set defaultAlloyConfig when empty.
apply_fab_overrides() {
    log_info "Applying fab.yaml overrides (tlsSAN + Alloy telemetry)..."

    local fab_file="$VLAB_WORK_DIR/fab.yaml"
    local prom_remote_url="${ALLOY_PROM_REMOTE_WRITE_URL:-$(default_prom_remote_write_url)}"

    if [ ! -f "$fab_file" ]; then
        log_error "fab.yaml not found at $fab_file"
        return 1
    fi

    if ! command -v python3 >/dev/null 2>&1; then
        log_error "python3 is required to patch fab.yaml"
        return 1
    fi

    # Collect candidate SAN values
    local sans
    sans=$(collect_tls_sans)

    # Default Alloy configuration targeting EMC Prometheus
    local alloy_config_json
    alloy_config_json=$(cat <<JSON
{
  "agentScrapeIntervalSeconds": 120,
  "unixScrapeIntervalSeconds": 120,
  "unixExporterEnabled": true,
  "collectSyslogEnabled": true,
  "prometheusTargets": {
    "emc": {
      "url": "${prom_remote_url}",
      "labels": {
        "env": "${ALLOY_PROM_LABEL_ENV}",
        "cluster": "${ALLOY_PROM_LABEL_CLUSTER}"
      },
      "sendIntervalSeconds": ${ALLOY_PROM_SEND_INTERVAL},
      "useControlProxy": true
    }
  },
  "unixExporterCollectors": [
    "cpu",
    "filesystem",
    "loadavg",
    "meminfo",
    "netdev",
    "diskstats"
  ]
}
JSON
)

    # Patch fab.yaml using Python to avoid brittle sed/awk edits
    # shellcheck disable=SC1009,SC1073,SC1072,SC1119
    local patch_result
    patch_result=$(FAB_PATH="$fab_file" TLS_SAN_INPUT="$sans" ALLOY_CONFIG_JSON="$alloy_config_json" python3 - <<'PY'
import os, json, yaml

fab_path = os.environ["FAB_PATH"]
alloy_config = json.loads(os.environ["ALLOY_CONFIG_JSON"])

raw_sans = os.environ.get("TLS_SAN_INPUT", "")
required_sans = [line.strip() for line in raw_sans.splitlines() if line.strip()]

seen = set()
ordered_sans = []
for entry in required_sans:
    if entry not in seen:
        ordered_sans.append(entry)
        seen.add(entry)

with open(fab_path, "r", encoding="utf-8") as f:
    docs = list(yaml.safe_load_all(f))

updated = False

for doc in docs:
    if not isinstance(doc, dict):
        continue
    if doc.get("kind") == "Fabricator":
        spec = doc.setdefault("spec", {}).setdefault("config", {})

        control = spec.setdefault("control", {})
        tls_san = control.get("tlsSAN") or []
        if not isinstance(tls_san, list):
            tls_san = []

        for entry in ordered_sans:
            if entry not in tls_san:
                tls_san.append(entry)
                updated = True

        control["tlsSAN"] = tls_san

        fabric = spec.setdefault("fabric", {})
        dac = fabric.get("defaultAlloyConfig")

        if not dac or dac == {}:
            fabric["defaultAlloyConfig"] = alloy_config
            updated = True
        else:
            # Only add missing keys; don't overwrite user-provided values
            for key, value in alloy_config.items():
                if key not in dac:
                    dac[key] = value
                    updated = True
        break

with open(fab_path, "w", encoding="utf-8") as f:
    yaml.safe_dump_all(docs, f, sort_keys=False)

print("updated" if updated else "nochange")
PY)

    local status=$?
    if [ $status -ne 0 ]; then
        log_error "Failed to patch fab.yaml (exit $status)"
        return $status
    fi

    log_info "fab.yaml patch result: $patch_result"
    return 0
}

# Helper: generate TLS SAN candidates (dedup handled in Python)
collect_tls_sans() {
    local entries=()

    add_san() {
        local value="$1"
        if [ -n "$value" ]; then
            entries+=("$value")
        fi
    }

    # Loopback and localhost
    add_san "127.0.0.1"
    add_san "localhost"

    # Common container bridge gateways
    add_san "172.19.0.1"   # k3d / docker network
    add_san "172.17.0.1"   # docker0 fallback

    # Hostnames
    add_san "$(hostname 2>/dev/null || true)"
    add_san "$(hostname -f 2>/dev/null || true)"

    # Primary non-loopback IP
    local primary_ip
    primary_ip=$(hostname -I 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i !~ /^127\./) {print $i; exit}}')
    add_san "$primary_ip"

    # GCP public IP (if present)
    local gcp_public_ip
    gcp_public_ip=$(curl -fs -H "Metadata-Flavor: Google" "http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/access-configs/0/external-ip" 2>/dev/null || true)
    add_san "$gcp_public_ip"

    # EMC service DNS names reachable via k3d network
    add_san "argocd-server.argocd"
    add_san "gitea-http.gitea"
    add_san "kube-prometheus-stack-prometheus.monitoring"

    # User-supplied extras (space or comma separated)
    if [ -n "$EXTRA_TLS_SANS" ]; then
        # Replace commas with spaces then iterate
        local extra_normalized
        extra_normalized=$(echo "$EXTRA_TLS_SANS" | tr ',' ' ')
        for val in $extra_normalized; do
            add_san "$val"
        done
    fi

    printf "%s\n" "${entries[@]}"
}

# Check if tmux session exists
session_exists() {
    tmux has-session -t "$TMUX_SESSION_NAME" 2>/dev/null
}

# Create and start tmux session with hhfab
start_tmux_session() {
    log_info "Starting hhfab VLAB in detached tmux session: $TMUX_SESSION_NAME"
    log_info "Command: $HHFAB_CMD"
    log_info "Working directory: $VLAB_WORK_DIR"
    log_info "Timeout: ${VLAB_TIMEOUT}s ($(( VLAB_TIMEOUT / 60 )) minutes)"

    cd "$VLAB_WORK_DIR" || {
        log_error "Failed to change to VLAB working directory"
        return 1
    }

    # Kill existing session if it exists
    if session_exists; then
        log_warn "Existing tmux session found. Killing it..."
        tmux kill-session -t "$TMUX_SESSION_NAME" 2>/dev/null || true
        sleep 2
    fi

    # Create new detached tmux session
    # The session will run hhfab and redirect all output to the log file
    # We capture the exit code AFTER the command completes (without exec)
    # Critical: Use printf to construct command with literal $? for sh to evaluate
    log_info "Creating detached tmux session..."

    # Build command using printf to avoid quote/expansion issues
    # This ensures $? is evaluated by sh inside tmux, not by the parent shell
    local tmux_cmd
    tmux_cmd=$(printf '%s >> %s 2>&1; echo $? > /tmp/hhfab-exit-code' \
        "$HHFAB_CMD" "'$LOG_FILE'")

    if ! tmux new-session -d -s "$TMUX_SESSION_NAME" -c "$VLAB_WORK_DIR" \
        sh -c "$tmux_cmd"; then
        log_error "Failed to create tmux session"
        return 1
    fi

    log_info "Tmux session '$TMUX_SESSION_NAME' created successfully"
    log_info "Students can view the session with: tmux attach -t $TMUX_SESSION_NAME"
    log_info "Or list sessions with: tmux ls"

    return 0
}

# Wait for hhfab to complete
wait_for_completion() {
    log_info "Waiting for VLAB initialization to complete..."
    log_info "This may take up to $(( VLAB_TIMEOUT / 60 )) minutes..."

    local start_time
    start_time=$(date +%s)
    local end_time
    end_time=$((start_time + VLAB_TIMEOUT))
    local check_interval=10
    local success_marker="All on-ready commands finished"

    while [ "$(date +%s)" -lt "$end_time" ]; do
        # Check if the tmux session still exists
        if ! session_exists; then
            log_info "Tmux session has exited"

            # Check exit code
            if [ -f /tmp/hhfab-exit-code ]; then
                local exit_code
                exit_code=$(cat /tmp/hhfab-exit-code)
                rm -f /tmp/hhfab-exit-code

                if [ "$exit_code" -eq 0 ]; then
                    log_info "hhfab vlab up completed successfully (exit code: 0)"
                    return 0
                else
                    log_error "hhfab vlab up failed with exit code: $exit_code"
                    log_error "Check logs at: $LOG_FILE"
                    return 1
                fi
            else
                log_error "Tmux session exited but no exit code found"
                return 1
            fi
        fi

        # Detect success marker even if hhfab keeps streaming logs
        if tail -n 200 "$LOG_FILE" | grep -q "$success_marker"; then
            log_info "Detected hhfab completion marker; leaving tmux session running for monitoring"
            return 0
        fi

        # Log progress
        local elapsed=$(($(date +%s) - start_time))
        log_info "Still waiting... (${elapsed}s elapsed, session is running)"

        sleep "$check_interval"
    done

    # Timeout reached
    log_error "VLAB initialization timed out after ${VLAB_TIMEOUT}s"
    log_error "Tmux session '$TMUX_SESSION_NAME' is still running but exceeded timeout"
    log_error "You can inspect it with: tmux attach -t $TMUX_SESSION_NAME"

    return 1
}

# Verify VLAB health
verify_vlab_health() {
    log_info "Verifying VLAB health..."

    cd "$VLAB_WORK_DIR" || return 1

    # Use hhfab vlab inspect to check switch status
    if hhfab vlab inspect >> "$LOG_FILE" 2>&1; then
        log_info "VLAB health check passed - all switches are operational"
        return 0
    else
        log_error "VLAB health check failed"
        return 1
    fi
}

# Create state marker
create_state_marker() {
    log_info "Creating VLAB initialization state marker..."

    mkdir -p "$(dirname "$STATE_FILE")"

    cat > "$STATE_FILE" <<EOF
{
  "initialized_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "tmux_session": "$TMUX_SESSION_NAME",
  "working_directory": "$VLAB_WORK_DIR",
  "version": "1.0.0"
}
EOF

    log_info "State marker created at: $STATE_FILE"
    return 0
}

# Main execution
main() {
    log_info "=================================================="
    log_info "hhfab VLAB Runner Starting..."
    log_info "=================================================="
    log_info "Tmux session: $TMUX_SESSION_NAME"
    log_info "Working directory: $VLAB_WORK_DIR"
    log_info "Log file: $LOG_FILE"
    log_info ""

    # Track overall start time
    local overall_start
    overall_start=$(date +%s)

    # Execute initialization steps
    if ! check_prerequisites; then
        log_error "Prerequisites check failed"
        return 1
    fi

    if ! init_vlab_workdir; then
        log_error "VLAB working directory initialization failed"
        return 1
    fi

    if ! apply_fab_overrides; then
        log_error "Failed to apply fab.yaml overrides"
        return 1
    fi

    if ! start_tmux_session; then
        log_error "Failed to start tmux session"
        return 1
    fi

    if ! wait_for_completion; then
        log_error "VLAB initialization failed or timed out"
        log_error "Tmux session may still be running for debugging"
        return 1
    fi

    if ! verify_vlab_health; then
        log_error "VLAB health verification failed"
        return 1
    fi

    if ! create_state_marker; then
        log_warn "Failed to create state marker (non-fatal)"
    fi

    # Calculate total time
    local overall_end
    overall_end=$(date +%s)
    local total_time
    total_time=$((overall_end - overall_start))

    log_info ""
    log_info "=================================================="
    log_info "hhfab VLAB Initialization Complete!"
    log_info "=================================================="
    log_info "Total time: ${total_time}s ($(( total_time / 60 )) minutes)"
    log_info "Tmux session: $TMUX_SESSION_NAME (continues running for ongoing monitoring)"
    log_info "Working directory: $VLAB_WORK_DIR"
    log_info "Log file: $LOG_FILE"
    log_info ""
    log_info "Note: The tmux session remains running to keep lab VMs alive."
    log_info "Attach for troubleshooting with: tmux attach -t $TMUX_SESSION_NAME"
    log_info ""

    return 0
}

# Run main function
main "$@"
exit $?
