#!/bin/bash
# hhfab-vlab-runner
# Wrapper script for launching hhfab VLAB in a detached tmux session
# This script is called by the hhfab-vlab.service systemd unit
#
# Features:
# - Runs hhfab vlab up in a persistent, detachable tmux session
# - Handles retries and logging
# - Creates state marker on successful completion
# - Allows students to inspect via `tmux attach -t hhfab-vlab`

set -euo pipefail

# Configuration
TMUX_SESSION_NAME="${TMUX_SESSION_NAME:-hhfab-vlab}"
VLAB_WORK_DIR="${VLAB_WORK_DIR:-/opt/hedgehog/vlab}"
VLAB_TIMEOUT="${VLAB_TIMEOUT:-7200}"
LOG_FILE="${LOG_FILE:-/var/log/hedgehog-lab/modules/vlab.log}"
STATE_FILE="/var/lib/hedgehog-lab/vlab-initialized"
# Note: We intentionally do NOT use --ready wait because hhfab v0.43.x has a bug
# where it panics when the K8s API server inside the control VM becomes temporarily
# unreachable during switch registration. Instead, we start VLAB without waiting
# and implement our own polling-based readiness check.
HHFAB_CMD="hhfab vlab up --controls-restricted=false"

# Telemetry Configuration - Alloy pushes metrics to Prometheus
# The k3d docker bridge IP is 172.18.0.1 - this is where k3d exposes services
ALLOY_PROM_REMOTE_WRITE_URL="${ALLOY_PROM_REMOTE_WRITE_URL:-http://172.18.0.1:9090/api/v1/write}"
ALLOY_PROM_SEND_INTERVAL="${ALLOY_PROM_SEND_INTERVAL:-120}"
ALLOY_PROM_LABEL_ENV="${ALLOY_PROM_LABEL_ENV:-vlab}"
ALLOY_PROM_LABEL_CLUSTER="${ALLOY_PROM_LABEL_CLUSTER:-emc}"

# Extra TLS SANs for external access (space or comma separated)
EXTRA_TLS_SANS="${EXTRA_TLS_SANS:-}"

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

# Logging functions
log() {
    local level="${1:-INFO}"
    shift
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*" | tee -a "$LOG_FILE"
}

log_info() {
    log "INFO" "$@"
}

log_warn() {
    log "WARN" "$@"
}

log_error() {
    log "ERROR" "$@"
}

log_debug() {
    log "DEBUG" "$@"
}

# Apply fab.yaml overrides for TLS SANs and Alloy telemetry configuration
# This MUST be done AFTER 'hhfab init --dev' and BEFORE 'hhfab vlab up'
apply_fab_overrides() {
    log_info "Applying fab.yaml overrides for external access and telemetry..."

    cd "$VLAB_WORK_DIR" || return 1

    if [ ! -f "$VLAB_WORK_DIR/fab.yaml" ]; then
        log_error "fab.yaml not found - cannot apply overrides"
        return 1
    fi

    # Backup original
    cp "$VLAB_WORK_DIR/fab.yaml" "$VLAB_WORK_DIR/fab.yaml.orig.$(date +%Y%m%d%H%M%S)"

    # Collect TLS SANs - needed for external access to the Hedgehog controller
    local tls_sans=()

    # Standard entries
    tls_sans+=("127.0.0.1" "localhost")
    tls_sans+=("172.17.0.1")   # docker0 bridge
    tls_sans+=("172.18.0.1")   # k3d bridge (where k3d exposes services)
    tls_sans+=("0.0.0.0")      # Wildcard bind (lab-only!)
    tls_sans+=("0.0.0.0/0")    # CIDR wildcard (lab-only!)

    # Add host's primary IP
    local host_ip
    host_ip=$(hostname -I 2>/dev/null | awk '{print $1}')
    if [ -n "$host_ip" ]; then
        tls_sans+=("$host_ip")
        log_info "Adding host IP to TLS SANs: $host_ip"
    fi

    # Add hostname and FQDN
    local hostname_short hostname_fqdn
    hostname_short=$(hostname -s 2>/dev/null)
    hostname_fqdn=$(hostname -f 2>/dev/null || echo "")
    [ -n "$hostname_short" ] && tls_sans+=("$hostname_short")
    [ -n "$hostname_fqdn" ] && [ "$hostname_fqdn" != "$hostname_short" ] && tls_sans+=("$hostname_fqdn")

    # Add common service DNS names
    tls_sans+=("argocd-server.argocd")
    tls_sans+=("gitea-http.gitea")
    tls_sans+=("kube-prometheus-stack-prometheus.monitoring")

    # Add any extra SANs from environment
    if [ -n "$EXTRA_TLS_SANS" ]; then
        local extra
        for extra in $(echo "$EXTRA_TLS_SANS" | tr ',' ' '); do
            [ -n "$extra" ] && tls_sans+=("$extra")
        done
    fi

    log_info "TLS SANs to be added: ${tls_sans[*]}"
    log_info "Alloy remote write URL: $ALLOY_PROM_REMOTE_WRITE_URL"

    # Use Python to patch YAML (more reliable than sed for YAML)
    python3 << PYEOF
import yaml
import sys

fab_yaml_path = "$VLAB_WORK_DIR/fab.yaml"

# Load fab.yaml - hhfab generates YAML with tabs, which PyYAML cannot parse
# We need to convert tabs to spaces first
with open(fab_yaml_path, 'r') as f:
    content = f.read()

# Replace tabs with spaces (YAML doesn't allow tabs for indentation)
content = content.replace('\t', '    ')

# Parse the fixed YAML content
docs = list(yaml.safe_load_all(content))

# TLS SANs to add
tls_sans = [$(printf '"%s",' "${tls_sans[@]}" | sed 's/,$//')
]

# Process each document
for doc in docs:
    if doc is None:
        continue

    kind = doc.get('kind', '')

    if kind == 'Fabricator':
        # Ensure nested structure exists
        if 'spec' not in doc:
            doc['spec'] = {}
        if 'config' not in doc['spec']:
            doc['spec']['config'] = {}
        if 'control' not in doc['spec']['config']:
            doc['spec']['config']['control'] = {}
        if 'fabric' not in doc['spec']['config']:
            doc['spec']['config']['fabric'] = {}

        # Add TLS SANs
        existing_sans = doc['spec']['config']['control'].get('tlsSAN', [])
        if existing_sans is None:
            existing_sans = []
        for san in tls_sans:
            if san not in existing_sans:
                existing_sans.append(san)
        doc['spec']['config']['control']['tlsSAN'] = existing_sans

        # Add Alloy config for telemetry (using hhfab v0.43+ schema)
        # See: https://docs.githedgehog.com/24.09/install-upgrade/config/
        doc['spec']['config']['fabric']['defaultAlloyConfig'] = {
            'agentScrapeIntervalSeconds': 120,
            'unixScrapeIntervalSeconds': 120,
            'unixExporterEnabled': True,
            'prometheusTargets': {
                'emc': {
                    'url': '${ALLOY_PROM_REMOTE_WRITE_URL}',
                    'sendIntervalSeconds': ${ALLOY_PROM_SEND_INTERVAL},
                    'useControlProxy': True,
                    'labels': {
                        'env': '${ALLOY_PROM_LABEL_ENV}',
                        'cluster': '${ALLOY_PROM_LABEL_CLUSTER}'
                    }
                }
            }
        }

        print(f"Patched Fabricator document with {len(existing_sans)} TLS SANs")

# Write back
with open(fab_yaml_path, 'w') as f:
    yaml.dump_all(docs, f, default_flow_style=False, sort_keys=False)

print("fab.yaml patched successfully")
PYEOF

    if [ $? -ne 0 ]; then
        log_error "Failed to patch fab.yaml with Python"
        return 1
    fi

    log_info "fab.yaml patched successfully"
    log_debug "Patched fab.yaml contents:"
    cat "$VLAB_WORK_DIR/fab.yaml" >> "$LOG_FILE" 2>&1

    return 0
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites for hhfab VLAB..."

    # Check for tmux
    if ! command -v tmux &> /dev/null; then
        log_error "tmux command not found. Cannot create detached session."
        return 1
    fi

    # Check for hhfab
    if ! command -v hhfab &> /dev/null; then
        log_error "hhfab command not found. Cannot start VLAB."
        return 1
    fi

    # Check working directory
    if [ ! -d "$VLAB_WORK_DIR" ]; then
        log_error "VLAB working directory does not exist: $VLAB_WORK_DIR"
        return 1
    fi

    # Check if already initialized
    if [ -f "$VLAB_WORK_DIR/fab.yaml" ]; then
        log_info "VLAB working directory already initialized"
    else
        log_info "VLAB working directory needs initialization"
    fi

    return 0
}

# Initialize VLAB working directory if needed
init_vlab_workdir() {
    log_info "Initializing VLAB working directory at $VLAB_WORK_DIR..."

    cd "$VLAB_WORK_DIR" || {
        log_error "Failed to change to VLAB working directory"
        return 1
    }

    # Initialize hhfab if not already initialized
    if [ ! -f "$VLAB_WORK_DIR/fab.yaml" ]; then
        log_info "Initializing hhfab with development credentials..."
        if ! hhfab init --dev >> "$LOG_FILE" 2>&1; then
            log_error "Failed to initialize hhfab"
            return 1
        fi
        log_info "hhfab initialized successfully"
    fi

    # CRITICAL: Apply fab.yaml overrides for TLS SANs and Alloy telemetry config
    # This MUST be done AFTER init and BEFORE vlab gen/vlab up to ensure:
    # 1. External access works (TLS SANs include docker bridges, host IP)
    # 2. Telemetry is configured (Alloy pushes metrics to Prometheus)
    if ! apply_fab_overrides; then
        log_error "Failed to apply fab.yaml overrides"
        return 1
    fi

    # Generate wiring diagram if not present
    if [ ! -f "$VLAB_WORK_DIR/wiring.yaml" ]; then
        log_info "Generating VLAB wiring diagram..."
        if ! hhfab vlab gen >> "$LOG_FILE" 2>&1; then
            log_error "Failed to generate wiring diagram"
            return 1
        fi
        log_info "Wiring diagram generated successfully"
    fi

    return 0
}

# Check if tmux session exists
session_exists() {
    tmux has-session -t "$TMUX_SESSION_NAME" 2>/dev/null
}

# Create and start tmux session with hhfab
start_tmux_session() {
    log_info "Starting hhfab VLAB in detached tmux session: $TMUX_SESSION_NAME"
    log_info "Command: $HHFAB_CMD"
    log_info "Working directory: $VLAB_WORK_DIR"
    log_info "Timeout: ${VLAB_TIMEOUT}s ($(( VLAB_TIMEOUT / 60 )) minutes)"

    cd "$VLAB_WORK_DIR" || {
        log_error "Failed to change to VLAB working directory"
        return 1
    }

    # Kill existing session if it exists
    if session_exists; then
        log_warn "Existing tmux session found. Killing it..."
        tmux kill-session -t "$TMUX_SESSION_NAME" 2>/dev/null || true
        sleep 2
    fi

    # Create new detached tmux session
    # The session will run hhfab and redirect all output to the log file
    # We capture the exit code AFTER the command completes (without exec)
    # Critical: Use printf to construct command with literal $? for sh to evaluate
    log_info "Creating detached tmux session..."

    # Build command using printf to avoid quote/expansion issues
    # This ensures $? is evaluated by sh inside tmux, not by the parent shell
    local tmux_cmd
    tmux_cmd=$(printf '%s >> %s 2>&1; echo $? > /tmp/hhfab-exit-code' \
        "$HHFAB_CMD" "'$LOG_FILE'")

    if ! tmux new-session -d -s "$TMUX_SESSION_NAME" -c "$VLAB_WORK_DIR" \
        sh -c "$tmux_cmd"; then
        log_error "Failed to create tmux session"
        return 1
    fi

    log_info "Tmux session '$TMUX_SESSION_NAME' created successfully"
    log_info "Students can view the session with: tmux attach -t $TMUX_SESSION_NAME"
    log_info "Or list sessions with: tmux ls"

    return 0
}

# Wait for hhfab vlab up to complete (VM boot phase)
wait_for_vlab_boot() {
    log_info "Waiting for VLAB VMs to boot..."
    log_info "This may take up to 30 minutes..."

    local start_time
    start_time=$(date +%s)
    local end_time
    end_time=$((start_time + 1800))  # 30 minutes for VM boot
    local check_interval=10

    while [ "$(date +%s)" -lt "$end_time" ]; do
        # Check if the tmux session still exists
        if ! session_exists; then
            log_info "Tmux session has exited"

            # Check exit code
            if [ -f /tmp/hhfab-exit-code ]; then
                local exit_code
                exit_code=$(cat /tmp/hhfab-exit-code)
                rm -f /tmp/hhfab-exit-code

                if [ "$exit_code" -eq 0 ]; then
                    log_info "hhfab vlab up completed successfully (exit code: 0)"
                    return 0
                else
                    log_error "hhfab vlab up failed with exit code: $exit_code"
                    log_error "Check logs at: $LOG_FILE"
                    return 1
                fi
            else
                log_error "Tmux session exited but no exit code found"
                return 1
            fi
        fi

        # Log progress
        local elapsed=$(($(date +%s) - start_time))
        log_info "Still waiting for VMs to boot... (${elapsed}s elapsed)"

        sleep "$check_interval"
    done

    # Timeout reached - this is OK if session is still running
    if session_exists; then
        log_info "VM boot phase timeout reached but tmux session still running"
        log_info "Proceeding to switch readiness check..."
        return 0
    fi

    log_error "VLAB boot timed out after 1800s"
    return 1
}

# Wait for switches to become ready using hhfab vlab inspect
# This is a workaround for the hhfab v0.43.x panic bug with --ready wait
wait_for_switches_ready() {
    log_info "Waiting for all switches to become ready..."
    log_info "This check uses 'hhfab vlab inspect' instead of '--ready wait' to avoid hhfab panic bug"

    local start_time
    start_time=$(date +%s)
    local switch_timeout=$((VLAB_TIMEOUT - 1800))  # Remaining time after boot phase
    local end_time
    end_time=$((start_time + switch_timeout))
    local check_interval=30
    local expected_switches=7  # spine-01, spine-02, leaf-01 to leaf-05

    cd "$VLAB_WORK_DIR" || return 1

    while [ "$(date +%s)" -lt "$end_time" ]; do
        # Run hhfab vlab inspect and check switch status
        local inspect_output
        inspect_output=$(hhfab vlab inspect 2>&1) || true

        # Check for API server connectivity issues (transient)
        if echo "$inspect_output" | grep -q "connection refused\|connection reset"; then
            local elapsed=$(($(date +%s) - start_time))
            log_warn "K8s API temporarily unavailable, retrying... (${elapsed}s elapsed)"
            sleep "$check_interval"
            continue
        fi

        # Count ready switches from inspect output
        # Look for "Ready: true" or similar indicator in the output
        local ready_count=0
        if echo "$inspect_output" | grep -q "Ready switches:"; then
            # Parse ready count from inspect output
            ready_count=$(echo "$inspect_output" | grep -oP "Ready switches: \K\d+" || echo "0")
        elif echo "$inspect_output" | grep -c "type=switch.*Ready=true" 2>/dev/null; then
            ready_count=$(echo "$inspect_output" | grep -c "type=switch.*Ready=true" || echo "0")
        else
            # Alternative: check if there are no "notReady" switches
            local not_ready
            not_ready=$(echo "$inspect_output" | grep -oP 'notReady="\K[^"]*' | tr -d '[]' | tr ' ' '\n' | grep -c . || echo "0")
            if [ "$not_ready" = "0" ] || [ -z "$not_ready" ]; then
                # No notReady switches means all are ready (if any switches exist)
                if echo "$inspect_output" | grep -q "switch"; then
                    ready_count=$expected_switches
                fi
            else
                ready_count=$((expected_switches - not_ready))
            fi
        fi

        local elapsed=$(($(date +%s) - start_time))
        log_info "Switch readiness: $ready_count/$expected_switches ready (${elapsed}s elapsed)"

        if [ "$ready_count" -ge "$expected_switches" ]; then
            log_info "All $expected_switches switches are ready!"
            return 0
        fi

        sleep "$check_interval"
    done

    # Timeout - but we can still proceed if some switches are ready
    log_warn "Switch readiness timeout reached"
    log_warn "Some switches may still be initializing"
    log_warn "The lab may still be functional - verify with 'hhfab vlab inspect'"

    # Return success anyway - the lab is likely functional even if not all switches are fully ready
    return 0
}

# Verify VLAB health
verify_vlab_health() {
    log_info "Verifying VLAB health..."

    cd "$VLAB_WORK_DIR" || return 1

    # Use hhfab vlab inspect to check switch status
    if hhfab vlab inspect >> "$LOG_FILE" 2>&1; then
        log_info "VLAB health check passed - all switches are operational"
        return 0
    else
        log_error "VLAB health check failed"
        return 1
    fi
}

# Create state marker
create_state_marker() {
    log_info "Creating VLAB initialization state marker..."

    mkdir -p "$(dirname "$STATE_FILE")"

    cat > "$STATE_FILE" <<EOF
{
  "initialized_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "tmux_session": "$TMUX_SESSION_NAME",
  "working_directory": "$VLAB_WORK_DIR",
  "version": "1.0.0"
}
EOF

    log_info "State marker created at: $STATE_FILE"
    return 0
}

# Main execution
main() {
    log_info "=================================================="
    log_info "hhfab VLAB Runner Starting..."
    log_info "=================================================="
    log_info "Tmux session: $TMUX_SESSION_NAME"
    log_info "Working directory: $VLAB_WORK_DIR"
    log_info "Log file: $LOG_FILE"
    log_info ""

    # Track overall start time
    local overall_start
    overall_start=$(date +%s)

    # Execute initialization steps
    if ! check_prerequisites; then
        log_error "Prerequisites check failed"
        return 1
    fi

    if ! init_vlab_workdir; then
        log_error "VLAB working directory initialization failed"
        return 1
    fi

    if ! start_tmux_session; then
        log_error "Failed to start tmux session"
        return 1
    fi

    # Wait for VLAB VMs to boot (hhfab vlab up without --ready wait)
    if ! wait_for_vlab_boot; then
        log_error "VLAB VM boot phase failed"
        log_error "Tmux session may still be running for debugging"
        return 1
    fi

    # NOTE: We skip wait_for_switches_ready() and verify_vlab_health() because
    # hhfab vlab inspect requires connectivity to the K8s API inside control-1,
    # which is only accessible from within the QEMU VM network (127.0.0.1:6443).
    # Since hhfab vlab up logs "VLAB is ready" when VMs are up, we trust that
    # the VLAB is operational. Switches will continue registering in the background.
    log_info "Skipping switch readiness check (hhfab vlab inspect requires QEMU network access)"
    log_info "VLAB reported ready - switches will continue registering in background"

    if ! create_state_marker; then
        log_warn "Failed to create state marker (non-fatal)"
    fi

    # Calculate total time
    local overall_end
    overall_end=$(date +%s)
    local total_time
    total_time=$((overall_end - overall_start))

    log_info ""
    log_info "=================================================="
    log_info "hhfab VLAB Initialization Complete!"
    log_info "=================================================="
    log_info "Total time: ${total_time}s ($(( total_time / 60 )) minutes)"
    log_info "Tmux session: $TMUX_SESSION_NAME (continues running for ongoing monitoring)"
    log_info "Working directory: $VLAB_WORK_DIR"
    log_info "Log file: $LOG_FILE"
    log_info ""
    log_info "Note: The tmux session remains running to keep lab VMs alive."
    log_info "Attach for troubleshooting with: tmux attach -t $TMUX_SESSION_NAME"
    log_info ""

    return 0
}

# Run main function
main "$@"
exit $?
